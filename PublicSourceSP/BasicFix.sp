/* Plugin Template generated by Pawn Studio */

#include <sourcemod>
#include <sourcemod>
#include <sdktools>
#include <l4d2util>
#include <sdkhooks>
#include <smlib>
#include <colors>

// - Enable/Disable "Fixes"
new Handle:g_hServerCVar             = INVALID_HANDLE;
new Handle:g_hPubBlock               = INVALID_HANDLE;

// - PubBlocker
new bool: bHandled = false;
new Handle: hTimer = INVALID_HANDLE;
new Handle: g_hReady = INVALID_HANDLE;

// - Ping Fix
new Handle:g_hCvarMode = INVALID_HANDLE;
new Handle:g_hCvarEnabled = INVALID_HANDLE;

new bool:g_bEnabled;
new g_iMode = 2;

new g_iPingOffset;

//<<<<<<<<<<<<<<<<<<<<< TICKRATE FIXES >>>>>>>>>>>>>>>>>>
//// ------- Slow Doors ----------
// **************************** 

//Cvars
new Handle:g_cvarDoors_Speed_Elevator 		= INVALID_HANDLE;
new Handle:g_cvarDoors_Speed 				= INVALID_HANDLE;
new Handle:g_cvarDoors_Speed_Prop 			= INVALID_HANDLE;

//Floats
new Float:g_flPlugin_Doors_Speed_Elevator 	= -1.0;
new Float:g_flPlugin_Doors_Speed 			= -1.0;
new Float:g_flPlugin_Doors_Speed_Prop 		= -1.0;

//Tracking
enum DoorsTypeTracked 
{
    DoorsTypeTracked_None = -1,
    DoorsTypeTracked_Func_Door = 0,
    DoorsTypeTracked_Func_Door_Rotating = 1,
    DoorsTypeTracked_Func_MoveLinear = 2,
    DoorsTypeTracked_Prop_Door = 3,
    DoorsTypeTracked_Prop_Door_Rotating = 4,
    DoorTypeTracked_Prop_Door_Rotating_Checkpoint = 5
};

new String:g_szDoors_Type_Tracked[][MAX_NAME_LENGTH] = {
    
    "func_door",
    "func_door_rotating",
    "func_movelinear",
    "prop_door",
    "prop_door_rotating",
    "prop_door_rotating_checkpoint"
};

enum DoorsData {
    
    DoorsTypeTracked:DoorsData_Type,
    Float:DoorsData_Speed,
    Float:DoorsData_BlockDamage,
    bool:DoorsData_ForceClose
}

new Float:g_ddDoors[2048][DoorsData];
new bool:g_bDoors_HasChangedValues = false;

//// ------- Fast Pistols ---------
// ***************************** 
//Cvars
new Handle:g_hPistolDelayDualies = INVALID_HANDLE;
new Handle:g_hPistolDelaySingle = INVALID_HANDLE;
new Handle:g_hPistolDelayIncapped = INVALID_HANDLE;

//Floats
new Float:g_fNextAttack[MAXPLAYERS + 1];
new Float:g_fPistolDelayDualies = 0.1;
new Float:g_fPistolDelaySingle = 0.2;
new Float:g_fPistolDelayIncapped = 0.3;

new Float:tickInterval;
new Float:tickRRate;

//// ------- Drop-down Damage Fix -------

//Cvar Check & Adjust
new Handle: g_hCvarGravity       = INVALID_HANDLE;
//*****************************************************************************
//*****************************************************************************
//-----------------------------------------------------------------------------

/*
* Version 1.0
* - Prevent Server CVar change Spam on Server Load.
* 
* Version 1.1
* - Integrated PubBlocker
* > Checks for l4d_ready_enabled cvar to decide whether to "activate"
* 
* - Added CVar Toggles for Functions
* 
* Version 1.2
* - Integrated Tickrate Fixes
* - Fixes are applied if Tickrate appears to be 60 or higher.
* 
* Version 1.3
* - Implemented a fix for an issue that causes SI to survive a melee attack (ZC 1-5)
* - Ping in scoreboard will be correct right away, rather than a high ping at first due to rate calculation.
* */

public Plugin:myinfo = 
{
    name = "L4D2 Game/Server Tweaks&Fixes",
    author = "Sir, Thrawn, Griffin, Chanz",
    description = "What Name says",
    version = "1.3",
}

public OnPluginStart()
{
    //CVars.
    g_hServerCVar = CreateConVar("GSTF_ServerCVar", "1", "Block Server CVar Changes being Broadcasted?");
    g_hPubBlock = CreateConVar("GSTF_BlockPub", "1", "Only allow Competitive Games on Server?");
    g_hReady = FindConVar("l4d_ready_enabled");
    
    //Server CVar
    HookEvent("server_cvar", Event_ServerCvar, EventHookMode_Pre);
    HookEvent("player_hurt", Event_Hurt);
    
    g_iPingOffset = FindSendPropInfo("CPlayerResource", "m_iPing");
    
    g_hCvarEnabled = CreateConVar("sm_trealping_enable", "1", "Enable tRealPing", FCVAR_PLUGIN, true, 0.0, true, 1.0);
    g_hCvarMode = CreateConVar("sm_trealping_mode", "2", "0: GetClientLatency, 1: GetClientAvgLatency, 2: Netgraph, 3: Scoreboard;", FCVAR_PLUGIN, true, 0.0, true, 3.0);
    
    HookConVarChange(g_hCvarEnabled, Cvar_Changed);
    HookConVarChange(g_hCvarMode, Cvar_Changed);
    
    //Is Server 60+ Tick?
    tickInterval = GetTickInterval();
    if(0.0 < tickInterval) tickRRate = 1.0/tickInterval;
    if(tickRRate >= 40)
    {
        //Manages Speed of Doors&Elevators
        g_cvarDoors_Speed_Elevator 		= CreateConVar("doors_speed_elevator", 	"1.05", "Sets the speed of all func_door entities used as elevators on a map.\nEx: 1.05 means +5% speed", FCVAR_PLUGIN);
        g_cvarDoors_Speed 				= CreateConVar("doors_speed", 			"1.05", "Sets the speed of all func_door entities that are not elevators on a map.\nEx: 1.05 means +5% speed", FCVAR_PLUGIN);
        g_cvarDoors_Speed_Prop			= CreateConVar("doors_speed_prop", 		"1.05", "Sets the speed of all prop_door entities on a map.\nEx: 1.05 means +5% speed", FCVAR_PLUGIN);
        
        //Hook Pistols
        for (new client = 1; client <= MaxClients; client++)
        {
            if (!IsClientInGame(client)) continue;
            SDKHook(client, SDKHook_PostThinkPost, Hook_OnPostThinkPost);
        }
        g_hPistolDelayDualies = CreateConVar("l4d_pistol_delay_dualies", "0.1", "Minimum time (in seconds) between dual pistol shots",
        FCVAR_PLUGIN | FCVAR_SPONLY | FCVAR_NOTIFY, true, 0.0, true, 5.0);
        g_hPistolDelaySingle = CreateConVar("l4d_pistol_delay_single", "0.2", "Minimum time (in seconds) between single pistol shots",
        FCVAR_PLUGIN | FCVAR_SPONLY | FCVAR_NOTIFY, true, 0.0, true, 5.0);
        g_hPistolDelayIncapped = CreateConVar("l4d_pistol_delay_incapped", "0.3", "Minimum time (in seconds) between pistol shots while incapped",
        FCVAR_PLUGIN | FCVAR_SPONLY | FCVAR_NOTIFY, true, 0.0, true, 5.0);
        
        UpdatePistolDelays();
        
        HookConVarChange(g_hPistolDelayDualies, Cvar_PistolDelay);
        HookConVarChange(g_hPistolDelaySingle, Cvar_PistolDelay);
        HookConVarChange(g_hPistolDelayIncapped, Cvar_PistolDelay);
        HookEvent("weapon_fire", Event_WeaponFire);
        
        //Gravity
        g_hCvarGravity = FindConVar("sv_gravity");
        if (GetConVarInt(g_hCvarGravity) != 750) SetConVarInt(g_hCvarGravity, 750);
    }
    
    bHandled = false;
}

public OnPluginEnd()
{
    if(g_bDoors_HasChangedValues && tickRRate >= 40) Door_ResetSettingsAll();
}

public OnClientPutInServer(client)
{
    if(tickRRate >= 40)
    {
        SDKHook(client, SDKHook_PreThink, Hook_OnPostThinkPost);
        g_fNextAttack[client] = 0.0;
    }
}

public OnClientDisconnect(client)
{
    SDKUnhook(client, SDKHook_PreThink, Hook_OnPostThinkPost);
}

public OnMapStart() 
{
    new iPlayerManager = -1;
    
    for(new iEntity = MaxClients+1; iEntity < GetMaxEntities(); iEntity++) {
        if(Entity_ClassNameMatches(iEntity, "_player_manager", true)) {
            iPlayerManager = iEntity;
            break;
        }
    }
    
    if(iPlayerManager == -1) {
        SetFailState("Unable to find \"*_player_manager\" entity");
    }
    
    SDKHook(iPlayerManager, SDKHook_ThinkPost, PlayerManager_OnThinkPost);
}

public OnConfigsExecuted()
{
    if(tickRRate >= 40)
    {
        g_flPlugin_Doors_Speed_Elevator 	= GetConVarFloat(g_cvarDoors_Speed_Elevator);
        g_flPlugin_Doors_Speed 				= GetConVarFloat(g_cvarDoors_Speed);
        g_flPlugin_Doors_Speed_Prop 		= GetConVarFloat(g_cvarDoors_Speed_Prop);
        
        HookConVarChange(g_cvarDoors_Speed_Elevator,	ConVarChange_Doors_Speed_Elevator);
        HookConVarChange(g_cvarDoors_Speed,				ConVarChange_Doors_Speed);
        HookConVarChange(g_cvarDoors_Speed_Prop,		ConVarChange_Doors_Speed_Prop);
    }
    
    g_bEnabled = GetConVarBool(g_hCvarEnabled);
    g_iMode = GetConVarInt(g_hCvarMode);
}

public PlayerManager_OnThinkPost(iEnt) 
{
    if(!g_bEnabled)return;
    
    new iPing[MAXPLAYERS+1];
    GetEntDataArray(iEnt, g_iPingOffset, iPing, MaxClients+1);
    
    for (new iClient = 1; iClient <= MaxClients; iClient++)	{
        if(IsClientInGame(iClient) && !IsFakeClient(iClient)) {
            switch(g_iMode)
            {
                case 0: {
                    new Float:fLatency = GetClientLatency(iClient, NetFlow_Both);
                    if(fLatency == -1)continue;						// Network info not available, e.g. a bot
                    
                    iPing[iClient] = RoundToNearest(fLatency * 500);
                }
                
                case 1: {
                    new Float:fLatency = GetClientAvgLatency(iClient, NetFlow_Both);
                    if(fLatency == -1)continue;						// Network info not available, e.g. a bot
                    
                    iPing[iClient] = RoundToNearest(fLatency * 500);
                }
                
                case 2: {
                    new iFakePing = Client_GetFakePing(iClient, false) - 10;
                    if(iFakePing == 0) continue;						// Network info not available, e.g. a bot
                    if(iFakePing < 0) iFakePing = 5;
                    iPing[iClient] = iFakePing;
                }
                
                case 3: {
                    new iFakePing = Client_GetFakePing(iClient, true);
                    if(iFakePing == 0)continue;						// Network info not available, e.g. a bot
                    iPing[iClient] = iFakePing;
                }
            }
        }
    }
    
    SetEntDataArray(iEnt, g_iPingOffset, iPing, MaxClients+1);
}

public Cvar_PistolDelay(Handle:convar, const String:oldValue[], const String:newValue[])
{
    UpdatePistolDelays();
}

public Cvar_Changed(Handle:convar, const String:oldValue[], const String:newValue[]) 
{
    OnConfigsExecuted();
}

public ConVarChange_Enable(Handle:cvar, const String:szOldVal[], const String:szNewVal[]){
    
    new oldVal = StringToInt(szOldVal);
    new newVal = StringToInt(szNewVal);
    
    if(oldVal == newVal){
        return;
    }
    
    if(g_bDoors_HasChangedValues) {
        
        Door_ResetSettingsAll();
    }
    
    if(newVal == 1){
        
        Door_ClearSettingsAll();
        Door_GetSettingsAll();
        Door_SetSettingsAll();
    }
}

public ConVarChange_Doors_Speed_Elevator(Handle:cvar, const String:oldVal[], const String:newVal[])
{
    g_flPlugin_Doors_Speed_Elevator = StringToFloat(newVal);
}

public ConVarChange_Doors_Speed(Handle:cvar, const String:oldVal[], const String:newVal[])
{
    g_flPlugin_Doors_Speed = StringToFloat(newVal);
}

public ConVarChange_Doors_Speed_Prop(Handle:cvar, const String:oldVal[], const String:newVal[])
{
    g_flPlugin_Doors_Speed_Prop = StringToFloat(newVal);
}

UpdatePistolDelays()
{
    g_fPistolDelayDualies = GetConVarFloat(g_hPistolDelayDualies);
    if (g_fPistolDelayDualies < 0.0) g_fPistolDelayDualies = 0.0;
    else if (g_fPistolDelayDualies > 5.0) g_fPistolDelayDualies = 5.0;
    
    g_fPistolDelaySingle = GetConVarFloat(g_hPistolDelaySingle);
    if (g_fPistolDelaySingle < 0.0) g_fPistolDelaySingle = 0.0;
    else if (g_fPistolDelaySingle > 5.0) g_fPistolDelaySingle = 5.0;
    
    g_fPistolDelayIncapped = GetConVarFloat(g_hPistolDelayIncapped);
    if (g_fPistolDelayIncapped < 0.0) g_fPistolDelayIncapped = 0.0;
    else if (g_fPistolDelayIncapped > 5.0) g_fPistolDelayIncapped = 5.0;
}

public Hook_OnPostThinkPost(client)
{
    // Human survivors only
    if (!IsClientInGame(client) || IsFakeClient(client) || GetClientTeam(client) != 2) return;
    new activeweapon = GetEntPropEnt(client, Prop_Send, "m_hActiveWeapon");
    if (!IsValidEdict(activeweapon)) return;
    decl String:weaponname[64];
    GetEdictClassname(activeweapon, weaponname, sizeof(weaponname));
    if (strcmp(weaponname, "weapon_pistol") != 0) return;
    
    new Float:old_value = GetEntPropFloat(activeweapon, Prop_Send, "m_flNextPrimaryAttack");
    new Float:new_value = g_fNextAttack[client];
    
    // Never accidentally speed up fire rate
    if (new_value > old_value)
    {
        // PrintToChatAll("Readjusting delay: Old=%f, New=%f", old_value, new_value);
        SetEntPropFloat(activeweapon, Prop_Send, "m_flNextPrimaryAttack", new_value);
    }
}

public Action:Event_WeaponFire(Handle:event, const String:name[], bool:dontBroadcast)
{
    new client = GetClientOfUserId(GetEventInt(event, "userid"));
    if (!IsClientInGame(client) || IsFakeClient(client) || GetClientTeam(client) != 2) return;
    new activeweapon = GetEntPropEnt(client, Prop_Send, "m_hActiveWeapon");
    if (!IsValidEdict(activeweapon)) return;
    decl String:weaponname[64];
    GetEdictClassname(activeweapon, weaponname, sizeof(weaponname));
    if (strcmp(weaponname, "weapon_pistol") != 0) return;
    // new dualies = GetEntProp(activeweapon, Prop_Send, "m_hasDualWeapons");
    if (GetEntProp(client, Prop_Send, "m_isIncapacitated"))
    {
        g_fNextAttack[client] = GetGameTime() + g_fPistolDelayIncapped;
    }
    // What is the difference between m_isDualWielding and m_hasDualWeapons ?
    else if (GetEntProp(activeweapon, Prop_Send, "m_isDualWielding"))
    {
        g_fNextAttack[client] = GetGameTime() + g_fPistolDelayDualies;
    }
    else
    {
        g_fNextAttack[client] = GetGameTime() + g_fPistolDelaySingle;
    }
}

Door_SetSettingsAll(){
    
    g_bDoors_HasChangedValues = true;
    
    new countEnts=0;
    new entity = -1;
    
    for(new i=0;i<sizeof(g_szDoors_Type_Tracked);i++){
        
        while ((entity = FindEntityByClassname(entity, g_szDoors_Type_Tracked[i])) != INVALID_ENT_REFERENCE){
            
            Door_SetSettings(entity);
            countEnts++;
        }
        
        entity = -1;
    }
}

Door_SetSettings(entity){
    
    if(g_ddDoors[entity][DoorsData_Type] == DoorsTypeTracked_None){
        return;
    }
    
    if(g_ddDoors[entity][DoorsData_Type] != DoorsTypeTracked_Func_MoveLinear) {
        
        Entity_SetForceClose(entity,false);
    }
    
    if(
    g_ddDoors[entity][DoorsData_Type] == DoorsTypeTracked_Prop_Door ||
    g_ddDoors[entity][DoorsData_Type] == DoorsTypeTracked_Prop_Door_Rotating
    ) {
        
        Entity_SetSpeed(entity,g_ddDoors[entity][DoorsData_Speed]*g_flPlugin_Doors_Speed_Prop);
    }
    else {
        
        new Float:moveDir[3];
        Entity_GetMoveDirection(entity,moveDir);
        Entity_SetSpeed(entity,g_ddDoors[entity][DoorsData_Speed]*((moveDir[2] == 1.0) ? g_flPlugin_Doors_Speed_Elevator : g_flPlugin_Doors_Speed));
        
        Entity_SetBlockDamage(entity,0.0);
    }
}

Door_ResetSettingsAll(){
    
    new countEnts=0;
    new entity = -1;
    
    for(new i=0;i<sizeof(g_szDoors_Type_Tracked);i++){
        
        while ((entity = FindEntityByClassname(entity, g_szDoors_Type_Tracked[i])) != INVALID_ENT_REFERENCE){
            
            Door_ResetSettings(entity);
            countEnts++;
        }
        
        entity = -1;
    }
}

Door_ResetSettings(entity){
    
    if(g_ddDoors[entity][DoorsData_Type] == DoorsTypeTracked_None){
        return;
    }
    
    if(g_ddDoors[entity][DoorsData_Type] != DoorsTypeTracked_Func_MoveLinear) {
        
        Entity_SetForceClose(entity,g_ddDoors[entity][DoorsData_ForceClose]);
    }
    
    if(
    g_ddDoors[entity][DoorsData_Type] != DoorsTypeTracked_Prop_Door &&
    g_ddDoors[entity][DoorsData_Type] != DoorsTypeTracked_Prop_Door_Rotating
    ) {
        Entity_SetBlockDamage(entity,g_ddDoors[entity][DoorsData_BlockDamage]);
    }
    
    Entity_SetSpeed(entity,g_ddDoors[entity][DoorsData_Speed]);
}

Door_GetSettingsAll(){
    
    new countEnts=0;
    new entity = -1;
    
    for(new i=0;i<sizeof(g_szDoors_Type_Tracked);i++){
        
        while ((entity = FindEntityByClassname(entity, g_szDoors_Type_Tracked[i])) != INVALID_ENT_REFERENCE){
            
            Door_GetSettings(entity,DoorsTypeTracked:i);
            countEnts++;
        }
        
        entity = -1;
    } 
}

Door_GetSettings(entity,DoorsTypeTracked:type){
    
    g_ddDoors[entity][DoorsData_Type] = type;
    
    if(g_ddDoors[entity][DoorsData_Type] != DoorsTypeTracked_Func_MoveLinear) {
        
        g_ddDoors[entity][DoorsData_ForceClose] = Entity_GetForceClose(entity);
    }
    
    if(
    g_ddDoors[entity][DoorsData_Type] != DoorsTypeTracked_Prop_Door &&
    g_ddDoors[entity][DoorsData_Type] != DoorsTypeTracked_Prop_Door_Rotating
    ) {
        
        g_ddDoors[entity][DoorsData_BlockDamage] = Entity_GetBlockDamage(entity);
    }
    
    g_ddDoors[entity][DoorsData_Speed] = Entity_GetSpeed(entity);
}

Door_ClearSettingsAll()
{
    g_bDoors_HasChangedValues = false;
    
    for(new i=0;i<sizeof(g_ddDoors);i++){
        
        g_ddDoors[i][DoorsData_Type] = DoorsTypeTracked_None;
        g_ddDoors[i][DoorsData_Speed] = 0.0;
        g_ddDoors[i][DoorsData_BlockDamage] = 0.0;
        g_ddDoors[i][DoorsData_ForceClose] = false;
    }
}

//Server Cvar
//-----------

public Action:Event_ServerCvar(Handle:event, const String:name[], bool:dontBroadcast)
{
    if(GetConVarBool(g_hServerCVar)) return Plugin_Handled;
    return Plugin_Continue;
}

//Block Non-Competitive Games
//---------------------------

public OnClientPostAdminCheck(client)
{
    if (bHandled && IsAdminHere() > 0) Handled();
    
    if(!GetConVarBool(g_hPubBlock) || bHandled || GetConVarBool(g_hReady) || IsAdminHere() > 0 || !CheckMaps()) return;
    
    if(IsValidClient(client) && !IsFakeClient(client))
    {
        bHandled = true;
        CreateTimer(25.0, NotifyPubs, _, TIMER_REPEAT);
        hTimer = CreateTimer(150.0, KickPubs);
    }
}

public OnClientDisconnect_Post(client)
{
    if(GetRealClientCount() == 0) Handled();
    else
    {
        if(!GetConVarBool(g_hPubBlock) || bHandled || GetConVarBool(g_hReady) || IsAdminHere() > 0 || !CheckMaps()) return;
        
        if(IsValidClient(client) && !IsFakeClient(client))
        {
            bHandled = true;
            CreateTimer(25.0, NotifyPubs, _, TIMER_REPEAT);
            hTimer = CreateTimer(150.0, KickPubs);
        }
    }	    
}

public Action:NotifyPubs(Handle:timer)
{
    if(!bHandled) return Plugin_Stop;
    
    CPrintToChatAll("{default}<{blue}PubBlocker{default}> {blue}Only use this server for {default}Competitive Play");
    CPrintToChatAll("{default}<{blue}PubBlocker{default}> {blue}Everyone will be kicked unless a {default}!match {blue}config is loaded");
    return Plugin_Continue;
}

public Action:KickPubs(Handle:timer)
{
    ServerCommand("sm_kick @all Only Competitive Play on this Server");
    Handled();
}

//Fix Melee Weapons not killing SI when they should
public Action:Event_Hurt(Handle:event, const String:name[], bool:dontBroadcast)
{
    decl String:weapon[25];
    GetEventString(event, "weapon", weapon, sizeof(weapon));
    new victim = GetClientOfUserId(GetEventInt(event, "userid"));
    new attacker = GetClientOfUserId(GetEventInt(event, "attacker"));
    
    //Melee Weapon?
    if (StrEqual(weapon, "melee", false)) 
    {
        //If Survivor/Charger/Tank/Witch/Dead Ignore.
        if(!IsPlayerAlive(victim) || GetClientTeam(victim) != 3 || GetEntProp(victim, Prop_Send, "m_zombieClass") > 5) return;
        
        //Kill the SI with his remaining health (+1 to avoid bugs)
        SDKHooks_TakeDamage(victim, 0, attacker, float(GetClientHealth(victim)+1));
    }
}



//Stocks and such
//------------------------------

bool:IsValidClient(client)
{
    if (client <= 0 || client > MaxClients) return false;
    if (!IsClientInGame(client)) return false;
    if (IsClientSourceTV(client) || IsClientReplay(client)) return false;
    return true;
}

GetRealClientCount() 
{
    new clients = 0;
    for (new i = 1; i <= GetMaxClients(); i++) 
    {
        if(IsClientInGame(i) && IsClientConnected(i) && !IsFakeClient(i)) clients++;
    }
    return clients;
}

IsAdminHere()
{
    new clients = 0;
    for (new i = 1; i <= GetMaxClients(); i++) 
    {
        if(IsClientInGame(i) && IsClientConnected(i) && Client_IsAdmin(i)) clients++;
    }
    return clients;
}

Handled()
{
    bHandled = false;
    if (hTimer != INVALID_HANDLE)
    {
        KillTimer(hTimer);
        hTimer = INVALID_HANDLE;
    }
}

// Check if Config has to be loaded - Makes exception for Custom Map play.
CheckMaps()
{
    decl String:mapname[128];
    GetCurrentMap(mapname, sizeof(mapname));
    
    if (strncmp(mapname, "c1", 2) == 0
    || strncmp(mapname, "c2", 2) == 0
    || strncmp(mapname, "c3", 2) == 0
    || strncmp(mapname, "c4", 2) == 0
    || strncmp(mapname, "c6", 2) == 0
    || strncmp(mapname, "c7", 2) == 0
    || strncmp(mapname, "c8", 2) == 0
    || strncmp(mapname, "c9", 2) == 0
    || strncmp(mapname, "c10", 3) == 0
    || strncmp(mapname, "c11", 3) == 0
    || strncmp(mapname, "c12", 3) == 0
    || strncmp(mapname, "c13", 3) == 0) return true;
    else if (strncmp(mapname, "c5", 2) == 0)
    {
        if (strncmp(mapname, "c5m1_dark", 9) != 0
        && strncmp(mapname, "c5m2_dark", 9) != 0
        && strncmp(mapname, "c5m3_dark", 9) != 0
        && strncmp(mapname, "c5m4_dark", 9) != 0
        && strncmp(mapname, "c5m5_dark", 9) != 0) return true;
    }
    
    return false; 
}
